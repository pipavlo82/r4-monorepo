# 🔐 R4 VRF — Verifiable Random Function

**On-chain verification for Re4ctoR entropy**

This package contains a Solidity smart contract that allows blockchain applications to verify that randomness was generated by an authorized Re4ctoR node.

---

## 📋 What's Inside

```
vrf-spec/
├── contracts/
│   └── R4VRFVerifier.sol    # Solidity verification contract
├── test/
│   └── verify.js            # Hardhat test suite
├── scripts/
│   └── deploy.js            # Deployment script
├── hardhat.config.js        # Hardhat configuration
└── package.json
```

---

## 🎯 Contract Overview

### **R4VRFVerifier.sol**

The contract provides two key functions:

#### 1. `verify(bytes32 randomness, bytes memory signature, address signer)`

**Purpose**: Verify that randomness was signed by the expected Re4ctoR node

**How it works**:
1. Recomputes the Ethereum signed message hash
2. Recovers the signer address from the ECDSA signature
3. Compares recovered address with the expected signer

**Returns**: `bool` — `true` if signature is valid

**Example**:
```solidity
bytes32 randomValue = 0x1234...;
bytes memory sig = hex"abcd...";
address re4ctorNode = 0x5678...;

bool isValid = verifier.verify(randomValue, sig, re4ctorNode);
require(isValid, "Invalid randomness signature");
```

#### 2. `submitRandom(bytes32 randomness, bytes memory signature)`

**Purpose**: Submit verified randomness on-chain and emit an event

**Behavior**:
- Calls `verify()` internally (uses contract deployer as signer)
- Reverts if signature is invalid
- Emits `RandomnessVerified(address indexed submitter, bytes32 randomness, uint256 timestamp)`

**Example**:
```solidity
contract Lottery {
    R4VRFVerifier public verifier;
    
    function drawWinner(bytes32 randomness, bytes memory signature) external {
        verifier.submitRandom(randomness, signature);
        
        // Use randomness to select winner
        uint256 winnerIndex = uint256(randomness) % players.length;
        payable(players[winnerIndex]).transfer(prize);
    }
}
```

---

## 🚀 Quick Start

### Prerequisites

- Node.js 16+
- npm or yarn

### Installation

```bash
cd vrf-spec
npm install
```

### Compile Contracts

```bash
npx hardhat compile
```

**Expected output**:
```
Compiled 1 Solidity file successfully (evm target: paris).
```

### Run Tests

```bash
npx hardhat test
```

**Expected output**:
```
R4VRFVerifier
  ✔ verifies a valid signature from the signer (424ms)
  ✔ emits event on submitRandom()

2 passing (448ms)
```

---

## 📦 Deployment

### Local Hardhat Network

```bash
# Terminal 1: Start local node
npx hardhat node

# Terminal 2: Deploy
npx hardhat run scripts/deploy.js --network localhost
```

### Sepolia Testnet

1. **Setup environment variables**:
```bash
# .env
SEPOLIA_RPC_URL=https://sepolia.infura.io/v3/YOUR_KEY
PRIVATE_KEY=your_private_key_here
ETHERSCAN_API_KEY=your_etherscan_key
```

2. **Deploy**:
```bash
npx hardhat run scripts/deploy.js --network sepolia
```

3. **Verify on Etherscan**:
```bash
npx hardhat verify --network sepolia DEPLOYED_ADDRESS
```

---

## 🧪 Test Suite Details

### Test 1: Valid Signature Verification

**Purpose**: Ensure the contract can verify valid ECDSA signatures

**Flow**:
1. Generate random `bytes32` value
2. Sign with Ethereum private key
3. Call `verify()` with correct signer address
4. Assert returns `true`

### Test 2: Event Emission

**Purpose**: Confirm `RandomnessVerified` event is emitted correctly

**Flow**:
1. Submit randomness with valid signature
2. Listen for `RandomnessVerified` event
3. Verify event contains correct data

### Running Specific Tests

```bash
# Run with verbose output
npx hardhat test --verbose

# Run with gas reporting
REPORT_GAS=true npx hardhat test

# Run specific test file
npx hardhat test test/verify.js
```

---

## 🔧 Integration Example

### End-to-End Workflow

**Step 1: Generate randomness** (Re4ctoR API)
```bash
curl -H "x-api-key: demo" \
  "http://localhost:8081/random?n=32&fmt=hex"

# Response:
# {
#   "random_hex": "a1b2c3...",
#   "timestamp": "2025-10-26 20:27:26"
# }
```

**Step 2: Sign randomness** (Python backend)
```python
from eth_account import Account
from eth_account.messages import encode_defunct
from web3 import Web3

# Load signer key
private_key = "0x..."
account = Account.from_key(private_key)

# Get randomness from Re4ctoR
random_hex = "a1b2c3d4..."
random_bytes32 = Web3.to_bytes(hexstr=random_hex)

# Sign
message = encode_defunct(random_bytes32)
signature = account.sign_message(message)

print(f"Signature: {signature.signature.hex()}")
```

**Step 3: Submit to blockchain** (JavaScript)
```javascript
const contract = new ethers.Contract(ADDRESS, ABI, signer);

const tx = await contract.submitRandom(
  randomBytes32,
  signature
);

const receipt = await tx.wait();
console.log('Randomness verified on-chain!');
console.log('Event:', receipt.events[0].args);
```

---

## 📊 Gas Costs

| Function | Gas (estimate) |
|----------|----------------|
| `verify()` | ~25,000 gas |
| `submitRandom()` | ~28,000 gas |

*Tested on Sepolia testnet*

---

## 🔐 Security Considerations

### Current Implementation (ECDSA)

✅ **Pros**:
- Widely supported across EVM chains
- Low gas costs
- Battle-tested cryptography

⚠️ **Limitations**:
- Vulnerable to quantum computers (Shor's algorithm)
- Centralized trust in Re4ctoR signer key

---

### ✅ Now Live: Post-Quantum RNG (Dilithium-3)

🔐 **What’s new**:
- Re4ctoR now serves **Dilithium-signed entropy** on port `8081`
- Available endpoints:
  - `/random_pq?n=32&fmt=hex`
  - `/verify_pq` (verifies signature)
- Dual-port system:
  - `:8080` → legacy entropy (ChaCha20 + HMAC)
  - `:8081` → **PQ entropy (Dilithium-3)**

🧪 Signature verification is handled in Python (`pqdilithium`) and can be ported to Rust/WASM for off-chain clients.

🧠 Roadmap:
- On-chain Dilithium verifier in Solidity (research ongoing)
- Kyber encapsulation for client-side entropy provisioning
- Threshold signing (multi-node consensus)

This strengthens the Re4ctoR VRF against **quantum threats** and positions it for **next-gen blockchain** applications.


---

## 🛠️ Development

### Adding New Tests

Create new test file in `test/`:

```javascript
// test/your-test.js
const { expect } = require("chai");

describe("YourFeature", function () {
  it("should do something", async function () {
    // Your test code
  });
});
```

### Linting & Formatting

```bash
# Lint Solidity
npm run lint:sol

# Format code
npm run format
```

---

## 🌐 Network Addresses

### Testnets

| Network | Contract Address | Explorer |
|---------|------------------|----------|
| Sepolia | `TBD` | [Etherscan](https://sepolia.etherscan.io) |
| Mumbai | `TBD` | [PolygonScan](https://mumbai.polygonscan.com) |

### Mainnet

| Network | Contract Address | Explorer |
|---------|------------------|----------|
| Ethereum | `TBD` (pending audit) | [Etherscan](https://etherscan.io) |
| Polygon | `TBD` (pending audit) | [PolygonScan](https://polygonscan.com) |

---

## 📚 Additional Resources

- [Re4ctoR API Documentation](../README.md)
- [Hardhat Documentation](https://hardhat.org/docs)
- [OpenZeppelin ECDSA Library](https://docs.openzeppelin.com/contracts/4.x/api/utils#ECDSA)
- [Ethereum Signed Message Format](https://eips.ethereum.org/EIPS/eip-191)
- [Post-Quantum RNG API (Dilithium)](../README.md#🔐-r4pq-dual-port-mode)

---

## 🤝 Contributing

Improvements welcome! Areas to help:

- [ ] Gas optimization
- [ ] Additional test coverage
- [ ] Multi-chain deployment scripts
- [ ] Post-quantum signature integration

---

## 📬 Contact

**Maintainer**: Pavlo Tvardovskyi  
**Email**: shtomko@gmail.com  
**GitHub**: [@pipavlo82](https://github.com/pipavlo82)

---

**© 2025 Re4ctoR Project** • Built with 🔐 for verifiable randomness
